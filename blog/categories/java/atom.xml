<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | zephiransasのチラシの裏]]></title>
  <link href="http://zephiransas.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://zephiransas.github.io/"/>
  <updated>2017-04-05T17:22:33+09:00</updated>
  <id>http://zephiransas.github.io/</id>
  <author>
    <name><![CDATA[Takafumi Yoshida (@zephiransas)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring BootのCSSをGulpで管理する]]></title>
    <link href="http://zephiransas.github.io/blog/2017/04/05/gulp-sass/"/>
    <updated>2017-04-05T16:13:17+09:00</updated>
    <id>http://zephiransas.github.io/blog/2017/04/05/gulp-sass</id>
    <content type="html"><![CDATA[<p>Spring BootのプロジェクトでもSASSが書きたい！という欲望から、Gulpを使ってSASSをコンパイルするようにしました。</p>

<p>基本Gulpでやってるので、出力先だけ変えれば、特にSpring Bootには関係ない気もしますが・・・</p>

<p>npmは既にインストールしてある前提で。</p>

<h2>フォルダの構成と基本方針</h2>

<p>フォルダ構成は以下のようなイメージ。</p>

<pre><code class="bash">├── assets
│   └── stylesheets
│       └── application.scss
├── gulpfile.js
├── package.json
└── src
    └── main
        └── resources
            └── static
                └── css
                    ├── maps
                    │   └── application.css.map
                    └── application.css
</code></pre>

<p>assets/stylesheets以下にSASSを配置し、これをGulpでコンパイル。</p>

<p>出力先をSpring BootのCSS配備先 <code>src/main/resources/static/css</code> にして、これをThymeleafから参照する、という方針です。</p>

<h2>必要なパッケージをインストールする</h2>

<p>まずは必要なパッケージをnpmでインストールしていきます。</p>

<pre><code class="bash">$ npm init
(以降、全てデフォルトで)
$ npm install --save-dev gulp gulp-sass gulp-sourcemaps gulp-minify-css gulp-plumber
</code></pre>

<p>これでpackage.jsonが作成され、node_modulesに依存ライブラリがインストールされます。node_modulesはgitignoreしておくといいでしょう。</p>

<h2>gulpfile.jsを作成する</h2>

<p>SASSをコンパイルできるようGulpのタスクを定義します。</p>

<pre><code class="javascript gulpfile.js">var gulp = require('gulp'),
    sass = require('gulp-sass'),
    sourcemaps = require('gulp-sourcemaps'),
    minifyCss = require('gulp-minify-css'),
    plumber = require('gulp-plumber');

gulp.task('sass', function(){
  gulp.src('assets/stylesheets/*.scss')
    .pipe(plumber())
    .pipe(sourcemaps.init())
    .pipe(sass())
    .pipe(minifyCss())
    .pipe(sourcemaps.write('./maps'))
    .pipe(gulp.dest('src/main/resources/static/css'))
});
</code></pre>

<p>まずscssファイルの置き場所を <code>gulp.src('assets/stylesheets/*.scss')</code> としてassets/stylesheetsディレクトリに設定します。</p>

<p><code>.pipe(sass())</code>でSASSのコンパイル、<code>.pipe(minifyCss())</code>でCSSの圧縮をしています。</p>

<p>圧縮したCSSだと、元のSASSでの場所がわからなくなるので <code>.pipe(sourcemaps.write('./maps'))</code>でmapファイルを作成します。</p>

<p><code>sourcemaps.write()</code>はデフォルトだとコンパイルされたcss内部にインラインでmapを書き込むので、別途mapsディレクトリにmapファイルを書き込むよう設定しておきます。こうしておくことでChromeなどのDeveloper toolで見たときにSASSの場所が分かるようになります。</p>

<p>最後に <code>.pipe(gulp.dest('src/main/resources/static/css'))</code>でCSS出力しています。</p>

<p>設定したタスクを実行します。</p>

<pre><code class="bash">$ gulp sass
</code></pre>

<p>これでCSSが出力されますので、あとはThymeleaf側から</p>

<pre><code class="html">&lt;link rel="stylesheet" type="text/css" href="@{/css/application.css}"/&gt;
</code></pre>

<p>として参照できます。</p>

<h2>SASSを分割したい</h2>

<p>よくあるケースとして、画面単位でSASSを分け、最終的なCSSでは1つにまとめてしまいたい、というケースがあります。
例えば、以下のようなイメージ。</p>

<pre><code class="bash">assets
└── stylesheets
    ├── modules &lt;- 各画面ごとのSASS
    │   ├── _hoge.scss
    │   └── _fuga.scss
    └── application.scss &lt;- modulesを全てimportしたい
</code></pre>

<p>こういった時にはgulp-sass-bulk-importが便利です。</p>

<pre><code class="bash">$ npm install --save-dev gulp-sass-bulk-import
</code></pre>

<p>としてgulp-sass-bulk-importをインストールした後、gulpfile.jsを修正します。</p>

<pre><code class="javascript gulpfile.js">var sassBulk = require('gulp-sass-bulk-import');

...

gulp.task('sass', function(){
  gulp.src('assets/stylesheets/*.scss')
    .pipe(plumber())
    .pipe(sourcemaps.init())
    .pipe(sassBulk()) # 追加
    .pipe(sass())
    .pipe(minifyCss())
    .pipe(sourcemaps.write('./maps'))
    .pipe(gulp.dest('src/main/resources/static/css'))
});
</code></pre>

<p>あとはapplication.scssで</p>

<pre><code class="css application.scss">@import "modules/*";
</code></pre>

<p>とすることで、modules内のSASSを含めて、CSSがコンパイルされます。</p>

<p>注意点として、modules以下のSASSファイルは、プレフィックスとしてアンダーバーが付与されています。付与しない場合は、modules以下のSASSも普通にコンパイルの対象になり、そのままdestに出力されてしまうので、これを防止するため、アンダーバーを付与しています。</p>

<h2>Bootstrapを使いたい</h2>

<p>まずBoostrapをnpmでインストールします。</p>

<pre><code class="bash">$ npm install --save-dev bootstrap@4.0.0-alpha.4
</code></pre>

<p>これでnode_modulesにBootstrapがインストールされたので、これをGulpから参照できるようgulpfile.jsを修正します。</p>

<pre><code class="javascript gulpfile.js">gulp.task('sass', function(){
  gulp.src('assets/stylesheets/*.scss')
    .pipe(plumber())
    .pipe(sourcemaps.init())
    .pipe(sassBulk()) # 追加
    .pipe(sass({
      includePaths: ['./node_modules/bootstrap/scss']   # 追加
    }))
    .pipe(minifyCss())
    .pipe(sourcemaps.write('./maps'))
    .pipe(gulp.dest('src/main/resources/static/css'))
});
</code></pre>

<p>あとはapplication.scssで</p>

<pre><code class="css application.scss">@import "bootstrap";
</code></pre>

<p>とするだけです。SASSのコンパイルを実行すると、application.cssにBootstrapのcssが含まれていることがわかります。</p>

<h2>参考など</h2>

<ul>
<li><a href="http://qiita.com/steelydylan/items/37aa028fa11046cf4f51">gulpの設定を簡単に行える、gulpfile generatorを作りました。</a></li>
<li><a href="http://steelydylan.github.io/gulp-generator/">gulp generator</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CircleCIでGradleのテストを並列実行する]]></title>
    <link href="http://zephiransas.github.io/blog/2017/03/10/ciecleci-and-gradle/"/>
    <updated>2017-03-10T09:32:48+09:00</updated>
    <id>http://zephiransas.github.io/blog/2017/03/10/ciecleci-and-gradle</id>
    <content type="html"><![CDATA[<p>現在開発を行っているプロジェクトでは、Spring Bootを使って開発を行っているのですが、そこでのテストをCI環境で実行できるよう設定を行ったので、その手順を書いておきます。</p>

<h2>CircleCIで普通にテストできるようにする</h2>

<p>最初は並列ではなく、1つのコンテナを使ってCircleCIでテストできるように設定を行います。まずcircle.ymlを以下のように準備。</p>

<pre><code class="yml circle.yml">machine:
  java:
    version: openjdk8
  timezone:
    Asia/Tokyo
  environment:
    _JAVA_OPTIONS: "-Xms512m -Xmx1024m"
    GRADLE_OPTS: '-Dorg.gradle.jvmargs="-Xmx1024m -XX:+HeapDumpOnOutOfMemoryError"'
  post:
    - sudo service postgresql stop

dependencies:
  override:
    - ./gradlew testClasses

database:
  post:
    - mysql -e 'create database [データベース名];'
    # flywayなどでのマイグレーション

test:
  override:
    - ./gradlew test
  post:
    - mkdir -p $CIRCLE_TEST_REPORTS/junit/ &amp;&amp; find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} $CIRCLE_TEST_REPORTS/junit/ \;:
</code></pre>

<h3>メモリ割り当てについて</h3>

<p>machine.environmentでJAVA_OPTIONSに"-Xms512m -Xmx1024m"を指定しています。これはCircleCIでは1つのコンテナには4Gのメモリが割当られており、その上限をこえると、コンテナがフリーズして、10分経過するとテスト失敗になるという現象に対応するためです。合わせてGRADLE_OPTSにも同様の設定をおこなっています。</p>

<p>このあたりの設定も状況によっては増やせる場合もありますので、テストを実行しながら、調整してみてください。</p>

<ul>
<li><a href="https://circleci.com/docs/1.0/oom/">Your build hit the 4G memory limit</a></li>
</ul>


<h3>使わないデータベースを止める</h3>

<p>CircleCIではデフォルトでPostgreSQLとMySQLがインストールされたコンテナが準備されます。machine.postで使わないデータベースを止めることで、貴重なメモリの使用量を抑えることができます。</p>

<p>今回テスト対象のデータベースはMySQLですので、PostgreSQLを止めてメモリを節約します。</p>

<h3>dependenciesでライブラリをダウンロードしておく</h3>

<p>CircleCIではdatabaseサイクルが終わったタイミングで、次回のビルドを高速に実行できるよう、依存ライブラリなどをキャッシュする仕組みがあります。</p>

<p>しかしGradleではテストを実行する直前まで依存ライブラリはダウンロードされず、通常のままだと依存ライブラリをキャッシュに含めることができません。</p>

<p>そこでdependencies.overrideにてtestClassesタスクを実行しておきます。こうすることで、依存ライブラリがダウンロードされ、databaseサイクル終了後にキャッシュが作成されるようになります。</p>

<h3>Spring Bootのprofileはciにする</h3>

<p>CircleCIで動かす場合はデータベースの接続先が開発環境などとは変わるはずですので、CircleCI専用のapplication.ymlをapplication-ci.ymlとして作成します。</p>

<pre><code class="yml application-ci.yml">spring:
  profiles:
    active: ci
  datasource:
    url: jdbc:mysql://localhost:3306/{データベース名}
    username: ubuntu
    password:
    driverClassName: com.mysql.jdbc.Driver
</code></pre>

<p>CircleCIのMySQLには上記の設定で接続可能です。次にテスト実行時に</p>

<pre><code class="bash">SPRING_PROFILES_ACTIVE=ci ./gradlew test
</code></pre>

<p>とすることで、application-ci.ymlのデータベース接続情報を使用するようになります。</p>

<h3>テスト実行結果を集約する</h3>

<p>test.postにて、テスト結果のxmlを$CIRCLE_TEST_REPORTSにコピーしておきます。こうすることで、CircleCIの画面からテスト結果を簡単に見ることができます。</p>

<pre><code class="bash">test:
  post:
    - mkdir -p $CIRCLE_TEST_REPORTS/junit/ &amp;&amp; find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} $CIRCLE_TEST_REPORTS/junit/ \;:
</code></pre>

<ul>
<li><a href="https://circleci.com/docs/1.0/test-metadata/#gradle-junit-results">Collecting test metadata</a></li>
</ul>


<h2>並列テストが実行できるようにする</h2>

<p>次にCircleCI+Gradleで並列テストをすることを考えてみます。</p>

<p>一般的に並列テストを行う場合は、テスト対象のクラスを取得し、これをノードそれぞれに均等に割り振ることでテストを分散して実行します。</p>

<p>Gradleにはデフォルトではテスト対象のクラスフィルタリングする昨日はあるのですが、対象クラスを個別に指定する方法はありません。</p>

<p><a href="https://docs.gradle.org/current/userguide/java_plugin.html#test_filtering">https://docs.gradle.org/current/userguide/java_plugin.html#test_filtering</a></p>

<p>ですので今回はGradle実行時に-Pオプションを指定し、以下のようにして対象クラスを一括して渡す方法を採用しています。</p>

<pre><code class="bash">./gradlew test -PtestFiles=./src/test/java/com/example/HogeTest ./src/test/java/com/example/FugaTest ....以下テスト対象クラスを列挙
</code></pre>

<p>まずは、このオプションを組み立てつつ、gradleｗ実行する専用のシェルスクリプト（circleci.sh)を準備します。</p>

<pre><code class="bash circleci.sh">testFiles=$(find ./src/test -name *Test.java | sort | awk "NR % ${CIRCLE_NODE_TOTAL} == ${CIRCLE_NODE_INDEX}")
echo $testFiles
SPRING_PROFILES_ACTIVE=ci ./gradlew :webapp:test -PtestFiles="$testFiles"
</code></pre>

<p>CircleCI上でビルドに使用しているノード数は環境変数CIRCLE_NODE_TOTALから、自身のノード番号は環境変数CIRCLE_NODE_INDEXから取得できますので、これをawkから利用しつつ、テスト対象クラスを分散させます。</p>

<p>次にbuild.gradle内では-Pオプションで渡されたtestFilesのみをテスト対象にするよう、includeTestsMatchingを使って設定を行います。</p>

<pre><code class="bash build.gradle">test {
  if (project.hasProperty("testFiles")) {
      ArrayList files = project.getProperties().get("testFiles")
              .replaceAll("./src/test/java/", "")
              .replaceAll("/", ".")
              .replaceAll(".java", "")
              .split("\\s+")
      for(String file : files) {
          println file
          filter {
              includeTestsMatching file
          }
      }
  }  
}
</code></pre>

<p>こうすることで-PtestFilesで指定されたもののみ、テストを行うことができます。</p>

<p>最後に、並列実行できるようcircle.ymlを修正します。</p>

<pre><code class="yml circle.yml">test:
  override:
    - ./circleci.sh:
        parallel: true
  post:
    - mkdir -p $CIRCLE_TEST_REPORTS/junit/ &amp;&amp; find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} $CIRCLE_TEST_REPORTS/junit/ \;:
        parallel: true
</code></pre>

<p>テストは先ほど作成したcircle.shを実行するようにしparallel: trueを付与して並列実行するようにします。<strong>parallel: trueはインデント4つであることに注意！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[スクフェス・ログサーバをつくった]]></title>
    <link href="http://zephiransas.github.io/blog/2016/12/31/schfeslogsvr/"/>
    <updated>2016-12-31T12:47:59+09:00</updated>
    <id>http://zephiransas.github.io/blog/2016/12/31/schfeslogsvr</id>
    <content type="html"><![CDATA[<p>今日は大晦日ですね。年末ですが今年も例によって、コード書いたりプラモ作ったり、普段の連休と同じくダラダラ過ごしております。</p>

<p>ところで今年の<a href="http://www.adventar.org/calendars/1360">ラブライブ！アドベントカレンダー</a>はチェックしましたか？
自分も20日目に<a href="https://zephiransas.goat.me/3OsFK6X7">劇場版ラブライブとμ’ｓメンバーのその後</a>というタイトルでエントリしてます。
今年はその他にも、さまざまな視点から見た素晴らしいエントリがたくさん集まってますので、ラブライバーならぜひチェックしてみてください。</p>

<p>で、22日目のエントリには<a href="https://twitter.com/hideo54">@hideo54</a>さんの<a href="https://blog.hideo54.com/archives/591">スクフェスのライブスコアを取得する”schfeslog”を作った話</a>というのがあります。
これはnodeで建てたプロキシを使って、スクフェスがサーバに送信してる通信内容をみて、ライブのプレイ結果をツイートすることができるツールです。</p>

<ul>
<li>hideo54/schfeslog - <a href="https://github.com/hideo54/schfeslog">https://github.com/hideo54/schfeslog</a></li>
</ul>


<p>これをみて「お、ツイートできるんなら、外部サーバにも送信できるんじゃね？」ってことで、早速コードを書いてみました。</p>

<p>まずはschfeslog側に外部サーバへの通信機能を実装しています。該当するPull Requestは<a href="https://github.com/hideo54/schfeslog/pull/4">こちら</a>。単純にプレイデータをJSON形式にして、設定でされたサーバにPOSTするだけです。</p>

<p>これを受信するサーバはこちら。</p>

<ul>
<li>zephiransas/schfeslogsvr - <a href="https://github.com/zephiransas/schfeslogsvr">https://github.com/zephiransas/schfeslogsvr</a></li>
</ul>


<p>送信されたプレイデータを一覧で見ることもできます。ちなみに私のプレイデータがこちら</p>

<ul>
<li>schfeslog - <a href="http://schfeslog.herokuapp.com/">http://schfeslog.herokuapp.com/</a></li>
</ul>


<p>見た目とかは、もうちょっと改善したいところです・・・</p>

<p>最近、ちょっとJavaの案件をやってるせいもあって、真面目にSpring Bootで書いています。こういったRESTなアプリケーションを作るにはSpring Bootはとても簡単でいいですね。</p>

<p>サーバ側は簡単に自分用に環境を作れるよう、Deploy to Herokuボタンも準備してますので、興味のあるかたはschfeslogと一緒に、ぜひ試してみてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven Wrapperを使ってプロジェクトで使うMavenのバージョンを指定する]]></title>
    <link href="http://zephiransas.github.io/blog/2016/05/23/maven-wrapper/"/>
    <updated>2016-05-23T16:34:12+09:00</updated>
    <id>http://zephiransas.github.io/blog/2016/05/23/maven-wrapper</id>
    <content type="html"><![CDATA[<p>Javaでの開発において、ライブラリのバージョン管理にMavenを用いているところはたくさんあると思います。</p>

<p>しかし、pom.xmlを使って各ライブラリのバージョンを管理していても、各開発者が使うMavenのバージョンを固定することはできません。</p>

<p>プロジェクトで使うMavenのバージョンを固定したい！そんな場合に使えるのがMaven Wrapperです。</p>

<ul>
<li>takari/maven-wrapper -　<a href="https://github.com/takari/maven-wrapper">https://github.com/takari/maven-wrapper</a></li>
</ul>


<h2>導入方法</h2>

<p>導入方法は至って簡単。</p>

<p>maven wrapperを適用したいプロジェクトに移動して、以下のコマンドを発行するだけ。</p>

<pre><code class="bash">mvn -N io.takari:maven:wrapper
</code></pre>

<p>これだけで、プロジェクトに以下のファイルが追加されます。</p>

<ul>
<li>mvnw - Maven Wrapper経由でmavenを実行するためのファイル</li>
<li>mvnw.cmd - mvnwのWindows版。Windowsで使う場合はこっちを使いましょう。</li>
<li>.mvnディレクトリ - maven wraperがダウンロードしてきたMavenのバイナリとかが入ってる</li>
</ul>


<p>上記のコマンドだと実行時の最新のバージョンが使用されるので、バージョンを指定したい場合はオプションで</p>

<pre><code class="bash">mvn -N io.takari:maven:wrapper -Dmaven=3.3.1
</code></pre>

<p>としてやりましょう。以降は今まで</p>

<pre><code class="bash">mvn clean
mvn package
</code></pre>

<p>としていたのをmvnwコマンドに置き換えるだけで</p>

<pre><code class="bash">./mvnw clean
./mvnw package
</code></pre>

<p>固定されたバージョンをMavenを利用することができます。</p>

<h1>.gitignoreの設定</h1>

<p>~~ Gitなどのバージョン管理にはmvnwとmvnw.cmdのみコミット対象とし、<strong>.mvnディレクトリはコミット対象外</strong>にしましょう。 ~~</p>

<p>はい、これウソでしたorz</p>

<p>正しくは「.mvnディレクトリもコミットしましょう」です。</p>

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">YOSHIDAさん慣れないジャバやるから</p>&mdash; やっぱりおいしい木村屋のパン (@razon) <a href="https://twitter.com/razon/status/734898775873884160">2016年5月24日</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>はい、その通りですね（真顔</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaプログラマがKindle50%還元セールで買っておくべきIT技術書]]></title>
    <link href="http://zephiransas.github.io/blog/2015/05/31/java-programmer-must-buy/"/>
    <updated>2015-05-31T22:29:48+09:00</updated>
    <id>http://zephiransas.github.io/blog/2015/05/31/java-programmer-must-buy</id>
    <content type="html"><![CDATA[<p>Kindle Storeでセールをやってるようです。今回は50%をポイント還元するってセールらしいです。</p>

<p>で、<a href="http://www.kinleit.link/web/post-4954#Web-2">こちら</a>を見てたらRubyやPHPはあっても、Javaがなかったので、ついカッとなってJavaプログラマ向けのオススメ技術書をチョイスしました。
セールは<strong>6/1の正午まで</strong>ですので、お早めにどーぞ。</p>

<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=zephiransas-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B00MIM1KFC" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>


<p>これは店頭で目次を見た程度です。わりと初心者向けな印象なので、これからJavaを勉強したい人にオススメです。</p>

<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=zephiransas-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B00V2WMQNE" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>


<p>いわずと知れた「パーフェクトシリーズ」のJava版。広範囲に網羅されているので、手元に置いておけば長く使えると思います。初心者でも可。</p>

<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=zephiransas-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B00JS1EHH4" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>


<p>これも「逆引きレシピシリーズ」のJava版。リファレンス的に使うのならコイツは鉄板。</p>

<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=zephiransas-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B00XTOSYIY" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>


<p>そもそもJava EEの日本語の本は少ないのですが、最新のJava EE7に対応した本。</p>

<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=zephiransas-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B0088L9I4W" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>


<p>1つ前のバージョンであるJava EE6の本。通称「金魚本」。Java EE6と多少古くはあるがJava EE7と全然違うというわけでもないので、未だに現役で使えるはず。内容はある程度Java EE6の仕組みを理解している人がリファレンス的に使う感じだと思います。</p>

<p>現場からは以上です。</p>
]]></content>
  </entry>
  
</feed>
