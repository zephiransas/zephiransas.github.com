<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby, | zephiransasのチラシの裏]]></title>
  <link href="http://zephiransas.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://zephiransas.github.com/"/>
  <updated>2015-07-08T12:50:39+09:00</updated>
  <id>http://zephiransas.github.com/</id>
  <author>
    <name><![CDATA[Takafumi Yoshida (@zephiransas)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[論理削除とeager_loadでN+1問題が発生する件]]></title>
    <link href="http://zephiransas.github.com/blog/2015/07/08/eager-load-with-paranoia/"/>
    <updated>2015-07-08T09:53:55+09:00</updated>
    <id>http://zephiransas.github.com/blog/2015/07/08/eager-load-with-paranoia</id>
    <content type="html"><![CDATA[<p>Railsアプリにて論理削除とeager_loadを合わせて使うとN+1問題が発生することに気づいたのでメモ。</p>

<h2>N+1問題を確認する</h2>

<p>まずはN+1問題が起きるようなモデルを作成します。よくあるブログアプリのような、ブログのエントリがあり、それにコメントが複数あるパターンです。</p>

<p>``` ruby
class Post &lt; ActiveRecord::Base
  attr_accessible :title,</p>

<pre><code>              :content
</code></pre>

<p>  has_many :comments
end</p>

<p>class Comment &lt; ActiveRecord::Base
  attr_accessible :post_id,</p>

<pre><code>              :name,
              :content
</code></pre>

<p>  belongs_to :post
end
```</p>

<p>適当なデータを入れた後、これに対してrails cで以下のようにレコードを取得します。</p>

<p><code>ruby
Post.all.each do |post|
  puts post.comments.first.name
end
</code></p>

<p>すると、以下のようなSQLが発行されます。</p>

<p><code>
Post Load (0.1ms)  SELECT "posts".* FROM "posts"
Comment Load (0.1ms)  SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 12 LIMIT 1
ユーザ1
Comment Load (0.1ms)  SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 13 LIMIT 1
ユーザ1
Comment Load (0.1ms)  SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 14 LIMIT 1
ユーザ1
...
（以下続く
</code></p>

<p>この場合は、<strong>対象となったPostの件数分、CommentsテーブルへのSQLが発行されることになります。</strong> これがN+1問題です。</p>

<h2>N+1問題に対処する</h2>

<p>これを解決するには、eager_loadを使うことが一般的です。つまり</p>

<p><code>ruby
Post.eager_load(:comments).each do |post|
  puts post.comments.first.name
end
</code></p>

<p>この場合のSQLは（一部簡略化しています）</p>

<p><code>
SQL (0.2ms)  SELECT "posts".*, "comments".*
FROM "posts" LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id"
</code></p>

<p>となります。Postsテーブルと一緒にCommentsテーブルを取得しているので、SQLが1回だけ発行されていることがわかります。</p>

<p>美しい理想の世界です。ﾊﾗｼｮｰ</p>

<h2>paranoiaを導入する</h2>

<p>さて本題。ここで<strong>うっかり論理削除を導入</strong>してみましょう。</p>

<p>Railsには論理削除に関するgemは多数ありますが、現在のデファクトスタンダードは<a href="https://github.com/radar/paranoia">paranoia</a>だと思います。まずはparanoiaをGemfileに記述します。</p>

<p><code>ruby Gemfile
gem 'paranoia', '~&gt; 1.0'  # Rails3系には1.0系を使用
</code></p>

<p>その後、モデルを以下のように変更します。</p>

<p>``` ruby
class Post &lt; ActiveRecord::Base
  acts_as_paranoid
  attr_accessible :title,</p>

<pre><code>              :content
</code></pre>

<p>  has_many :comments
end</p>

<p>class Comment &lt; ActiveRecord::Base
  acts_as_paranoid
  attr_accessible :post_id,</p>

<pre><code>              :name,
              :content
</code></pre>

<p>  belongs_to :post
end
```</p>

<p>その後、eager_loadしてみます。</p>

<p><code>ruby
Post.eager_load(:comments).each do |post|
  puts post.comments.first.name
end
</code></p>

<p>するとSQLは以下の様に発行されます。（一部簡略化しています）</p>

<p><code>
SQL (0.2ms)  SELECT "posts".*, "comments".*
FROM "posts" LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id"
WHERE ("posts".deleted_at IS NULL)
</code></p>

<p>PostsテーブルのWHERE条件にdeleted_at is nullが付与されているのは期待通りですが、Commentsテーブルには付与されていないので、これでは<strong>論理削除されたCommentsテーブルの内容</strong>も取得してしまいます・・・</p>

<p>では、以下のようにPostのcommentsにconditionsを付与するのはどうでしょう？</p>

<p>``` ruby
class Post &lt; ActiveRecord::Base
  acts_as_paranoid
  attr_accessible :title,</p>

<pre><code>              :content
</code></pre>

<p>  has_many :comments, conditions: &lsquo;comments.deleted_at is null&rsquo;
end
```</p>

<p>ここで同様にeager_loadするとSQLは以下の様に発行されます。</p>

<p><code>
SQL (0.2ms)  SELECT "posts".*, "comments".*
FROM "posts" LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id" AND comments.deleted_at is null
WHERE ("posts".deleted_at IS NULL)
</code></p>

<p>WHERE条件が追加されて、なんだか、いい感じにeager_loadできました。</p>

<h2>論理削除したデータも取得したい場合</h2>

<p>さて、ここで少々頭がおかしくなって「削除したCommentも取りたい(^q^)」という気分になったとしましょう。</p>

<p>そこでPostクラスにcomments_with_deletedなるアソシエーションを追加します。</p>

<p>``` ruby
class Post &lt; ActiveRecord::Base
  acts_as_paranoid
  attr_accessible :title,</p>

<pre><code>              :content
</code></pre>

<p>  has_many :comments, conditions: &lsquo;comments.deleted_at is null&rsquo;
  has_many :comments_with_deleted,</p>

<pre><code>       class_name: 'Comment',
       foreign_key: :post_id
</code></pre>

<p>end
```</p>

<p>さて、これを使ってeager_loadしてみましょう。</p>

<p><code>
Post.eager_load(:comments_with_deleted).each do |post|
  puts post.comments.first.name
end
</code></p>

<p>すると、以下のようなSQLが発行されます。</p>

<p><code>
SQL (0.2ms)  SELECT "posts".*, "comments".* FROM "posts" LEFT OUTER JOIN "comments" ON "comments"."id" = "posts"."id" WHERE ("posts".deleted_at IS NULL)
Comment Load (0.1ms)  SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 12 AND ("comments".deleted_at IS NULL) AND (comments.deleted_at is null) LIMIT 1
ユーザ2
Comment Load (0.1ms)  SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 13 AND ("comments".deleted_at IS NULL) AND (comments.deleted_at is null) LIMIT 1
ユーザ1
Comment Load (0.1ms)  SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 14 AND ("comments".deleted_at IS NULL) AND (comments.deleted_at is null) LIMIT 1
ユーザ1
Comment Load (0.1ms)  SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 15 AND ("comments".deleted_at IS NULL) AND (comments.deleted_at is null) LIMIT 1
ユーザ1
Comment Load (0.1ms)  SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 16 AND ("comments".deleted_at IS NULL) AND (comments.deleted_at is null) LIMIT 1
</code></p>

<p>最初のSQLでは、条件にcomments.deleted_at is nullが付与されていないので、これは期待通りなのですが、<strong>その後、なぜかN+1問題が再発</strong>しています。</p>

<p><del>現在のところ、これを回避できる方法は見つけられていません。</del></p>

<ul>
<li>追記</li>
</ul>


<p>我らのひむひむセンセイから、アドバイスを頂きました。</p>

<blockquote class="twitter-tweet" lang="ja"><p lang="ja" dir="ltr"><a href="https://twitter.com/zephiransas">@zephiransas</a> &#10;Post.eager_load(:comments_with_deleted).each do |post|&#10; puts <a href="http://t.co/FVIFkHFf3H">http://t.co/FVIFkHFf3H</a>&#10;end&#10;的な感じじゃダメなんかね <a href="https://twitter.com/hashtag/%E3%81%A6%E3%81%8D%E3%81%A8%E3%81%86?src=hash">#てきとう</a></p>&mdash; えいる (@eielh) <a href="https://twitter.com/eielh/status/618621108854652929">2015, 7月 8</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>なるほど！やってみましょう。</p>

<p><code>
Post.eager_load(:comments_with_deleted).each do |post|
  puts post.comments_with_deleted.first.name
end
</code></p>

<p>するとSQLは</p>

<p><code>
SELECT "posts".
SQL (0.2ms)  SELECT "posts".*, "comments".* FROM "posts" LEFT OUTER JOIN
ON "comments"."post_id" = "posts"."id"
WHERE ("posts".deleted_at IS NULL)
</code></p>

<p>となって、意図した結果になりましたとさ。</p>

<p>でもこれ、実装時に意識しながら書ける自信ないですわ・・・(´・3・`)</p>

<h2>結論</h2>

<p>結論を<a href="http://blog.oukasoft.com/OS/">社畜ちゃん</a>にまとめていただきます。</p>

<p><img src="/images/20150708/summary.png" alt="summary" /></p>

<p>とは言っても論理武装が必要でしょうから、こちらも合わせてどうぞ。</p>

<ul>
<li>DELETE_FLAG を付ける前に確認したいこと。 &ndash; <a href="http://qiita.com/Jxck_/items/156d0a231c6968f2a474">http://qiita.com/Jxck_/items/156d0a231c6968f2a474</a></li>
<li>論理削除が云々について &ndash; <a href="http://mike-neck.hatenadiary.com/entry/2015/03/24/231422">http://mike-neck.hatenadiary.com/entry/2015/03/24/231422</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
